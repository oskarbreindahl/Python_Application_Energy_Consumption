\fancyhead[R]{Python Application Energy Consumption}
\section{Background \& Terminology}
\label{sec:background}

\subsection*{Measuring Device Energy Consumption}
There are two main ways to measure the energy consumption of electronic devices. One is to use internal, software-based solutions, like Intel's \textit{RAPL} (Running Average Power Limit)\cite{khan2018rapl}. Tools like RAPL let the user query device energy consumption directly through a terminal or code, making it easy to use and implement. However, these tools require the device to have the right software installed, and are not available on all platforms. Additionally, they are not as accurate as the other option, which is physical, external power meters plugged into the device being measured\cite{kavanagh2019rapid}. The \textit{Otii Ace Pro} is one such external power meter\cite{otii_website}. The Otii Ace Pro acts as the power supply for the device being measured, allowing for extremely accurate measurements. In this thesis, the Otii Ace Pro will be referred to simply as \textit{the Otii}. The Otii mainly measures three things: The \textit{power draw}, measured in Watts; the \textit{current}, measured in Ampere; and the \textit{voltage}, measured in Volts. For our experiment, we focus on the power draw, as it is directly linked to device energy consumption. The length of the recordings made on the Otii is used to determine the \textit{runtime} in seconds of the given benchmark. The \textit{energy consumption} of the device during recording can then be calculated by multiplying the runtime with the average power draw, giving the consumption measured in Joule. In this thesis, we will be using the terms power draw, runtime and energy consumption as defined above extensively when discussing results and findings.

\subsection*{Raspberry Pi}
\textit{Raspberry Pi} is a line of single-board computers developed and produced by the Raspberry Pi Foundation\cite{raspberry_pi_website}. The Raspberry Pi is small and supports many common interfaces, making it a popular choice for use in IoT devices\cite{zhao2015exploring}. Raspberry Pis are used in the experiment presented in this paper for two main reasons: Firstly, their low power draw lets them be easily powered by the Otii and secondly, their use of SD cards as main storage makes switching between operating systems and software configurations fast and easy. Two versions of the Raspberry Pi are used: The \textit{Raspberry Pi 3B+} and the \textit{Raspberry Pi 4B}. The main difference between them is the central processing unit, or \textit{CPU}: a \textit{Broadcom Cortex-A53} for the Raspberry Pi 3B+ and a \textit{Broadcom Cortex-A72} for the Raspberry Pi 4B. Both processors are made with the so-called \textit{ARM} architecture. The main improvements from the A53 to the A72 are the clock speed, from 1.4 GHz to 1.8 GHz, and the A72's ability to do out-of-order execution, making it able to use its resources much more efficiently. In this thesis, the Raspberry Pi 3B+ will also be referred to as \textit{the RPi3B+}, the Raspberry Pi 4B also as \textit{the RPi4B} and both collectively as \textit{the RPis}.

\subsection*{Operating Systems}
Most computers use an \textit{operating system}, or \textit{OS} that manages interfacing between applications and hardware. While there are many operating systems to choose from, this thesis will be focusing on the following four: \textit{Alpine}\cite{alpine_website}, \textit{FreeBSD}\cite{freebsd_website}, \textit{Manjaro}\cite{manjaro_website} and \textit{Ubuntu}\cite{ubuntu_website}. All of these operating systems are what are called \textit{Unix-like}, but FreeBSD is independently developed, while the three others are what are called \textit{Linux distributions} or \textit{distros}. Linux distros are all built with the Linux kernel but often use differing supporting system software and libraries. Ubuntu is derived from another distro, \textit{Debian}, Manjaro is derived from \textit{Arch Linux} while Alpine is not derived from any other distro. These facts make the four OSs different enough that they can be meaningfully compared. Additionally, they are all free, and support both the RPi3B+ and RPi4B, which are the primary reasons they were chosen for the experiment in this thesis. For our experiment, we use so-called minimal versions of the four OSs. This means that they have no desktop environment, only a command line interface. All of the versions are purpose-made for Raspberry Pis or similar devices using the ARM processor architecture. Links to the specific OS versions used can be found in the repository.

\subsection*{Python}
\textit{Python} is a programming language widely used in software development, with some sources even claiming it to be the most popular programming language in the world\cite{djurdjev2024popularity}\cite{tiobe}. This ubiquity makes Python an ideal language for benchmarking energy efficiency, as it increases the relevance of results. Python is open-source developed, meaning anyone can contribute to the language on the official Github page\cite{python_repo}. The standard implementation of Python is called \textit{CPython}. In this thesis, the term Python will always refer to CPython. The versions of Python tested in the experiment in this thesis are the newest release of the five most recent versions of Python at the time of writing: Python3.9.22, 3.10.17, 3.11.12, 3.12.10 and 3.13.3. These versions will be denoted by their major version number and first minor version number, e.g. "Python3.9", or sometimes "Py3.9" for the sake of brevity.

\subsection*{Pyperformance}
Pyperformance is an open-source benchmarking tool used and developed by the developers of Python. When the developers report performance improvements, as seen in the release notes for Python3.12\cite{py312}, Pyperformance has been used to measure those improvements. The source code for Pyperformance is available on GitHub\cite{pyperf_git}. Pyperformance is installed with the Python package manager \textit{pip} for the individual Python version one wants to test, and benchmarks can then be run through a command line interface. For the experiment shown in this thesis, the benchmarks in the "app" package are used, which includes the benchmarks \texttt{2to3}, \texttt{tornado\_http} and \texttt{chameleon}. Our main reason for choosing these three benchmarks is that they are presented by the Pyperformance documentation as being "\textit{'High-level' applicative benchmarks}"\cite{pyperf_docs}, which should make the results of the experiment more relevant to software practitioners.
